/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "crc.h"
#include "gpio.h"
#include "fsmc.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
 
#include "u8g2.h"
#include "u8g_arm.h"
#include <stdio.h>
#include <stdlib.h>
#include "math.h"


/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */


/* Параметры экрана */
#define SCREEN_W 160
#define SCREEN_H 160
#define SPRITE_COUNT 100
#define SPRITE_RADIUS 5  // радиус окружности

/* Spatial hash параметры */
#define GRID_SIZE 20  // размер ячейки (рекомендую >= 2*радиус)
#define GRID_W ((SCREEN_W / GRID_SIZE) + 1)
#define GRID_H ((SCREEN_H / GRID_SIZE) + 1)
#define MAX_PER_CELL 50

/* Структура спрайта: координаты центра, size = радиус */
typedef struct {
    float x;   // центр x
    float y;   // центр y
    float vx;  // скорость x
    float vy;  // скорость y
    int size;  // радиус в пикселях
    int num;   // номер спрайта
} Sprite;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */ 
   u8g2_t u8g2;
   static const unsigned char u8g2_logo_128x64_bits[];
   
 

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */



/* Заглушка: отрисовать квадрат на дисплее в позиции (ix, iy).
   Реализуйте в своём проекте: очистка предыдущего положения и рисование нового. */
/* Отрисовка круга по центру */
void Display_DrawCircleAtCenter(int cx, int cy, int size, int num)
{
    int r = size / 2;  // радиус из диаметра
    u8g2_DrawDisc(&u8g2, cx, cy, r, U8G2_DRAW_ALL);
}

/* Массив спрайтов */
static Sprite s[SPRITE_COUNT];

/* Простой генератор случайных чисел */
static uint32_t rng_state = 12345;
static inline uint32_t simple_rand(void) {
    rng_state = rng_state * 1103515245u + 12345u;
    return (rng_state >> 16) & 0x7FFFu;
}
static inline float randf(float min, float max) {
    return min + (simple_rand() / 32768.0f) * (max - min);
}

/* Grid cell для spatial hashing */
typedef struct {
    int count;
    int indices[MAX_PER_CELL];
} GridCell;
static GridCell grid[GRID_W][GRID_H];

/* Очистка сетки */
static inline void grid_clear(void) {
    for (int gx = 0; gx < GRID_W; ++gx)
        for (int gy = 0; gy < GRID_H; ++gy)
            grid[gx][gy].count = 0;
}

/* Добавление спрайта в сетку */
static inline void grid_insert(int idx) {
    int gx = (int)(s[idx].x / GRID_SIZE);
    int gy = (int)(s[idx].y / GRID_SIZE);
    if (gx < 0) gx = 0; if (gx >= GRID_W) gx = GRID_W - 1;
    if (gy < 0) gy = 0; if (gy >= GRID_H) gy = GRID_H - 1;
    GridCell *cell = &grid[gx][gy];
    if (cell->count < MAX_PER_CELL) {
        cell->indices[cell->count++] = idx;
    }
}

/* Проверка пересечения двух кругов */
static inline int circles_intersect(const Sprite *a, const Sprite *b)
{
    float dx = a->x - b->x;
    float dy = a->y - b->y;
    float r = a->size + b->size;  // сумма радиусов
    return (dx*dx + dy*dy) <= (r * r);
}

/* Обработка столкновения кругов (равные массы, с коэффициентом упругости) */
static void handle_collision_circle(Sprite *a, Sprite *b)
{
    float dx = a->x - b->x;
    float dy = a->y - b->y;
    float dist2 = dx*dx + dy*dy;
    
    if (dist2 < 0.01f) { 
        // Почти совпадающие центры — разводим в случайную сторону
        dx = randf(-1.0f, 1.0f);
        dy = randf(-1.0f, 1.0f);
        dist2 = dx*dx + dy*dy;
        if (dist2 < 0.01f) { dx = 1.0f; dy = 0.0f; dist2 = 1.0f; }
    }
    
    float dist = sqrtf(dist2);
    float nx = dx / dist;  // нормаль от b к a
    float ny = dy / dist;

    /* проекции скоростей на нормаль */
    float va_n = a->vx * nx + a->vy * ny;
    float vb_n = b->vx * nx + b->vy * ny;

    /* относительная скорость сближения */
    float rel_vel = va_n - vb_n;
    
    /* если расходятся — не обрабатываем */
    if (rel_vel <= 0.0f) return;

    /* коэффициент упругости */
    const float e = 0.8f;

    /* импульс (для равных масс упрощается) */
    float impulse = -(1.0f + e) * rel_vel * 0.5f;

    a->vx += impulse * nx;
    a->vy += impulse * ny;
    b->vx -= impulse * nx;
    b->vy -= impulse * ny;

    /* убрать перекрытие */
    float r_sum = (float)(a->size + b->size);
    float overlap = r_sum - dist;
    if (overlap > 0.0f) {
        float shift = (overlap + 0.1f) * 0.5f;  // +0.1 для избежания залипания
        a->x += nx * shift;
        a->y += ny * shift;
        b->x -= nx * shift;
        b->y -= ny * shift;
    }
}

/* Проверка столкновений в соседних ячейках */
static inline void grid_check_collisions(int idx) {
    int gx = (int)(s[idx].x / GRID_SIZE);
    int gy = (int)(s[idx].y / GRID_SIZE);
    if (gx < 0) gx = 0; if (gx >= GRID_W) gx = GRID_W - 1;
    if (gy < 0) gy = 0; if (gy >= GRID_H) gy = GRID_H - 1;

    for (int dx = -1; dx <= 1; ++dx) {
        for (int dy = -1; dy <= 1; ++dy) {
            int ngx = gx + dx;
            int ngy = gy + dy;
            if (ngx < 0 || ngx >= GRID_W || ngy < 0 || ngy >= GRID_H) continue;
            GridCell *cell = &grid[ngx][ngy];
            for (int i = 0; i < cell->count; ++i) {
                int other = cell->indices[i];
                if (other <= idx) continue;
                if (circles_intersect(&s[idx], &s[other])) {
                    handle_collision_circle(&s[idx], &s[other]);
                }
            }
        }
    }
}

/* Инициализация спрайтов */
void init_sprites(void) {
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        s[i].num = i;
        s[i].size = SPRITE_RADIUS;
        float r = (float)s[i].size;
        s[i].x = randf(r, SCREEN_W - r);
        s[i].y = randf(r, SCREEN_H - r);
        s[i].vx = randf(-30.0f, 30.0f);
        s[i].vy = randf(-30.0f, 30.0f);
    }
}





/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_FSMC_Init();
  MX_CRC_Init();
  /* USER CODE BEGIN 2 */

  
  
  
      u8g2_Setup_uc1698u_cg160160(&u8g2, U8G2_R0, u8x8_byte_hw_fsmc, u8x8_gpio_and_delay_template);     
      u8g2_InitDisplay(&u8g2); // send init sequence to the display, display is in sleep mode after this,
      u8g2_SetPowerSave(&u8g2, 0); // wake up display
      u8g2_ClearDisplay(&u8g2);       
      u8g2_SetContrast(&u8g2, 180); 
      
      
      
//      u8g2_SetFontMode(&u8g2, 0);  
      u8g2_SetFont(&u8g2, u8g2_font_logisoso18_tf);
      u8g2_SetDrawColor(&u8g2, 1);
//      u8g2_SetFontMode(&u8g2, 1);
       

      u8g2_SetFlipMode(&u8g2, 0);
      
      
      u8g2_ClearBuffer(&u8g2); 
      
       u8g2_DrawDisc(&u8g2, 3, 3, 3, U8G2_DRAW_ALL);
      
//      u8g2_DrawXBM(&u8g2, 20, 40, 128, 64, u8g2_logo_128x64_bits);     
      u8g2_SendBuffer(&u8g2);     
      
      
 /** Comment out the while(1) loop if you need a dynamic image with squares **/     
//    while(1);
     
  
      
      
#define DALAY_TIME      500 
      
      HAL_Delay(DALAY_TIME);
      
    /* Инициализация спрайтов */
  init_sprites();
  uint32_t last = uwTick;

    while (1) {
    uint32_t now = uwTick;
    float dt = (now - last) / 1000.0f;
    if (dt <= 0.0f) continue;
    if (dt > 0.05f) dt = 0.05f;  // ограничиваем dt для стабильности
    last = now;

    /* Обновление позиций и отражение от стен */
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        s[i].x += s[i].vx * dt;
        s[i].y += s[i].vy * dt;
        float r = (float)s[i].size;

        if (s[i].x - r < 0.0f) {
            s[i].x = r;
            s[i].vx = -s[i].vx;
        } else if (s[i].x + r > SCREEN_W) {
            s[i].x = SCREEN_W - r;
            s[i].vx = -s[i].vx;
        }

        if (s[i].y - r < 0.0f) {
            s[i].y = r;
            s[i].vy = -s[i].vy;
        } else if (s[i].y + r > SCREEN_H) {
            s[i].y = SCREEN_H - r;
            s[i].vy = -s[i].vy;
        }
    }

    /* Spatial hashing и обработка столкновений */
    grid_clear();
    for (int i = 0; i < SPRITE_COUNT; ++i) grid_insert(i);
    for (int i = 0; i < SPRITE_COUNT; ++i) grid_check_collisions(i);

    /* Отрисовка */
    u8g2_ClearBuffer(&u8g2);
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        int cx = (int)roundf(s[i].x);
        int cy = (int)roundf(s[i].y);
        u8g2_DrawDisc(&u8g2, cx, cy, s[i].size, U8G2_DRAW_ALL);
    }
    u8g2_SendBuffer(&u8g2);
  }


    
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  
    
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_5);
  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_5)
  {
  }
  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
  LL_RCC_HSE_Enable();

   /* Wait till HSE is ready */
  while(LL_RCC_HSE_IsReady() != 1)
  {

  }
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 168, LL_RCC_PLLP_DIV_2);
  LL_RCC_PLL_Enable();

   /* Wait till PLL is ready */
  while(LL_RCC_PLL_IsReady() != 1)
  {

  }
  while (LL_PWR_IsActiveFlag_VOS() == 0)
  {
  }
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_4);
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);

   /* Wait till System clock is ready */
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
  {

  }
  LL_SetSystemCoreClock(168000000);

   /* Update the time base */
  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */



//u8g2_logo_128x64_width 128
//u8g2_logo_128x64_height 64

static const unsigned char u8g2_logo_128x64_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xcf, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x83, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xf8,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0xfc, 0x03, 0x1c, 0x00, 0x3e, 0x1c, 0xc0, 0x03, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xff, 0x07, 0x7f, 0x80, 0xff,
   0x3f, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xff,
   0x8f, 0xff, 0xc1, 0xff, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x87, 0xff, 0xdf, 0xff, 0xc1, 0xc3, 0x07, 0x7c, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x87, 0x0f, 0xfe, 0xff, 0xe3, 0x81,
   0x03, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x07,
   0xfc, 0xe3, 0xe3, 0x81, 0x07, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0xc7, 0x07, 0xf8, 0xc1, 0xe7, 0x81, 0x87, 0xff, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03, 0xf0, 0x80, 0xe7, 0xc3,
   0x87, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03,
   0x70, 0x80, 0xc7, 0xe7, 0x83, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0xc7, 0x03, 0x78, 0x80, 0xc7, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03, 0xf8, 0xc0, 0x87, 0xff,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x07,
   0xfc, 0xc1, 0xc7, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0xc0, 0x87, 0x0f, 0xfe, 0xff, 0xe3, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x78, 0xc0, 0x83, 0xff, 0xdf, 0xff, 0xe3, 0x03,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf1, 0x03, 0xff,
   0x8f, 0xff, 0xe1, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0x01, 0xfe, 0x0f, 0xff, 0xc0, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x00, 0xfc, 0x03, 0x7c, 0xc0, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0xf8,
   0x01, 0x00, 0xe0, 0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x1e, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00,
   0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x20, 0xf0, 0xc7, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x40, 0x24, 0x20, 0x00, 0x00, 0x08, 0x46, 0x02,
   0x00, 0x80, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x6e, 0x6a, 0xc0,
   0xa4, 0x48, 0x04, 0xaa, 0xac, 0x8c, 0xaa, 0xac, 0x00, 0x00, 0x00, 0x00,
   0x6a, 0xa4, 0xaa, 0x20, 0xea, 0xa4, 0x64, 0x66, 0xaa, 0x46, 0x4a, 0x8a,
   0x00, 0x00, 0x00, 0x00, 0x4c, 0xa4, 0xaa, 0x20, 0xaa, 0xa2, 0x44, 0x2a,
   0xaa, 0x28, 0xaa, 0x4c, 0x00, 0x00, 0x00, 0x00, 0xe8, 0xa8, 0x6c, 0xc4,
   0xa4, 0x42, 0xee, 0x2a, 0xcc, 0x26, 0x6c, 0xe8, 0x00, 0x00, 0x00, 0x00,
   0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };








/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
