/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "crc.h"
#include "gpio.h"
#include "fsmc.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
 
#include "u8g2.h"
#include "u8g_arm.h"
#include <stdio.h>
#include <stdlib.h>
#include "math.h"


/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
/* Квадрат */
/* Структура спрайта */
typedef struct {
    float x, y;
    float vx, vy;
    uint8_t size;
    uint8_t num;
} Sprite;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */ 
   u8g2_t u8g2;
   static const unsigned char u8g2_logo_128x64_bits[];
   
 

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */



/* Заглушка: отрисовать квадрат на дисплее в позиции (ix, iy).
   Реализуйте в своём проекте: очистка предыдущего положения и рисование нового. */
void Display_DrawSquare(int ix, int iy, int size, int num)
{
  u8g2_DrawBox(&u8g2, ix, iy, size, size);
}  




  
  /* Параметры экрана */
#define SCREEN_W 160
#define SCREEN_H 160
#define SPRITE_COUNT 1000
#define SPRITE_SIZE 2

/* Массив спрайтов */
Sprite s[SPRITE_COUNT];








/* Прототипы (если нужны) */
static inline int rects_intersect(const Sprite *a, const Sprite *b);
static void handle_collision(Sprite *a, Sprite *b);

/* AABB пересечение — возвращает 1 если пересекаются */
static inline int rects_intersect(const Sprite *a, const Sprite *b)
{
    return !(
        (a->x + a->size <= b->x) ||
        (b->x + b->size <= a->x) ||
        (a->y + a->size <= b->y) ||
        (b->y + b->size <= a->y)
    );
}

/* Простая обработка столкновения:
   - обмен нормальных компонент скоростей (равные массы, эластичное)
   - убирает перекрытие простым push */
static void handle_collision(Sprite *a, Sprite *b)
{
    /* центры */
    float axc = a->x + a->size * 0.5f;
    float ayc = a->y + a->size * 0.5f;
    float bxc = b->x + b->size * 0.5f;
    float byc = b->y + b->size * 0.5f;

    float nx = axc - bxc;
    float ny = ayc - byc;
    if (nx == 0.0f && ny == 0.0f) { nx = 1.0f; ny = 0.0f; }

    float nlen = sqrtf(nx*nx + ny*ny);
    if (nlen == 0.0f) return;
    nx /= nlen; ny /= nlen;

    /* проекции скоростей на нормаль */
    float adot = a->vx * nx + a->vy * ny;
    float bdot = b->vx * nx + b->vy * ny;

    /* обмен нормальных компонент */
    float adot_new = bdot;
    float bdot_new = adot;

    a->vx += (adot_new - adot) * nx;
    a->vy += (adot_new - adot) * ny;
    b->vx += (bdot_new - bdot) * nx;
    b->vy += (bdot_new - bdot) * ny;

    /* убрать перекрытие (по максимальной оси) */
    float overlap_x = (a->size + b->size) * 0.5f - fabsf(axc - bxc);
    float overlap_y = (a->size + b->size) * 0.5f - fabsf(ayc - byc);
    float push = (overlap_x > overlap_y) ? overlap_x : overlap_y;
    if (push > 0.0f) {
        float shift = push * 0.5f;
        a->x += nx * shift;
        a->y += ny * shift;
        b->x -= nx * shift;
        b->y -= ny * shift;
    }
}















/* Простой генератор случайных чисел (если нет rand) */
static uint32_t rng_state = 12345;
static inline uint32_t simple_rand(void) {
    rng_state = rng_state * 1103515245 + 12345;
    return (rng_state >> 16) & 0x7FFF;
}
static inline float randf(float min, float max) {
    return min + (simple_rand() / 32768.0f) * (max - min);
}

/* Инициализация спрайтов */
void init_sprites(void) {
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        s[i].num = i;
        s[i].size = SPRITE_SIZE;
        s[i].x = randf(0, SCREEN_W - SPRITE_SIZE);
        s[i].y = randf(0, SCREEN_H - SPRITE_SIZE);
        s[i].vx = randf(-20.0f, 20.0f);
        s[i].vy = randf(-20.0f, 20.0f);
    }
}

/* Spatial hashing для оптимизации коллизий */
#define GRID_SIZE 10  // размер ячейки сетки (2×размер спрайта)
#define GRID_W ((SCREEN_W / GRID_SIZE) + 1)
#define GRID_H ((SCREEN_H / GRID_SIZE) + 1)
#define MAX_PER_CELL 50  // макс объектов в ячейке

typedef struct {
    int count;
    int indices[MAX_PER_CELL];
} GridCell;

GridCell grid[GRID_W][GRID_H];

/* Очистка сетки */
static inline void grid_clear(void) {
    for (int gx = 0; gx < GRID_W; ++gx)
        for (int gy = 0; gy < GRID_H; ++gy)
            grid[gx][gy].count = 0;
}

/* Добавление спрайта в сетку */
static inline void grid_insert(int idx) {
    int gx = (int)(s[idx].x / GRID_SIZE);
    int gy = (int)(s[idx].y / GRID_SIZE);
    if (gx < 0) gx = 0; if (gx >= GRID_W) gx = GRID_W - 1;
    if (gy < 0) gy = 0; if (gy >= GRID_H) gy = GRID_H - 1;
    
    if (grid[gx][gy].count < MAX_PER_CELL) {
        grid[gx][gy].indices[grid[gx][gy].count++] = idx;
    }
}

/* Проверка столкновений в соседних ячейках */
static inline void grid_check_collisions(int idx) {
    int gx = (int)(s[idx].x / GRID_SIZE);
    int gy = (int)(s[idx].y / GRID_SIZE);
    if (gx < 0) gx = 0; if (gx >= GRID_W) gx = GRID_W - 1;
    if (gy < 0) gy = 0; if (gy >= GRID_H) gy = GRID_H - 1;
    
    /* Проверяем текущую и соседние ячейки (3×3) */
    for (int dx = -1; dx <= 1; ++dx) {
        for (int dy = -1; dy <= 1; ++dy) {
            int ngx = gx + dx;
            int ngy = gy + dy;
            if (ngx < 0 || ngx >= GRID_W || ngy < 0 || ngy >= GRID_H) continue;
            
            GridCell *cell = &grid[ngx][ngy];
            for (int i = 0; i < cell->count; ++i) {
                int other = cell->indices[i];
                if (other <= idx) continue;  // избегаем двойных проверок
                
                if (rects_intersect(&s[idx], &s[other])) {
                    handle_collision(&s[idx], &s[other]);
                }
            }
        }
    }
}








/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_FSMC_Init();
  MX_CRC_Init();
  /* USER CODE BEGIN 2 */

  
  
  
      u8g2_Setup_uc1698u_cg160160(&u8g2, U8G2_R3, u8x8_byte_hw_fsmc, u8x8_gpio_and_delay_template);     
      u8g2_InitDisplay(&u8g2); // send init sequence to the display, display is in sleep mode after this,
      u8g2_SetPowerSave(&u8g2, 0); // wake up display
      u8g2_ClearDisplay(&u8g2);       
      u8g2_SetContrast(&u8g2, 180); 
      
      
      
      u8g2_SetFontMode(&u8g2, 0);  
      u8g2_SetFont(&u8g2, u8g2_font_logisoso18_tf);
      u8g2_SetDrawColor(&u8g2, 2);
      u8g2_SetFontMode(&u8g2, 1);
       

      u8g2_SetFlipMode(&u8g2, 0);
      
      
      u8g2_ClearBuffer(&u8g2);      
      u8g2_DrawXBM(&u8g2, 20, 40, 128, 64, u8g2_logo_128x64_bits);     
      u8g2_SendBuffer(&u8g2);     
      
      
 /** Comment out the while(1) loop if you need a dynamic image with squares **/     
//    while(1);
     
  
      
      
#define DALAY_TIME      500 
      
      HAL_Delay(DALAY_TIME);
      
  init_sprites();
uint32_t last = uwTick;

while(1) {      
    uint32_t now = uwTick;
    float dt = (now - last) / 1000.0f;
    if (dt <= 0.0f) continue;
    if (dt > 0.05f) dt = 0.05f;
    last = now;

    /* Обновление позиций и отражение от стен */
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        s[i].x += s[i].vx * dt;
        s[i].y += s[i].vy * dt;

        if (s[i].x < 0.0f) {
            s[i].x = -s[i].x;
            s[i].vx = -s[i].vx;
        }
        if (s[i].x + s[i].size > SCREEN_W) {
            float over = s[i].x + s[i].size - SCREEN_W;
            s[i].x -= 2.0f * over;
            s[i].vx = -s[i].vx;
        }
        if (s[i].y < 0.0f) {
            s[i].y = -s[i].y;
            s[i].vy = -s[i].vy;
        }
        if (s[i].y + s[i].size > SCREEN_H) {
            float over = s[i].y + s[i].size - SCREEN_H;
            s[i].y -= 2.0f * over;
            s[i].vy = -s[i].vy;
        }
    }

    /* Spatial hashing для быстрых коллизий */
    grid_clear();
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        grid_insert(i);
    }
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        grid_check_collisions(i);
    }

    /* Отрисовка */
    u8g2_ClearBuffer(&u8g2);
    for (int i = 0; i < SPRITE_COUNT; ++i) {
        Display_DrawSquare((int)s[i].x, (int)s[i].y, s[i].size, s[i].num);
    }
    u8g2_SendBuffer(&u8g2);
}

    
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  
    
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  LL_FLASH_SetLatency(LL_FLASH_LATENCY_5);
  while(LL_FLASH_GetLatency()!= LL_FLASH_LATENCY_5)
  {
  }
  LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
  LL_RCC_HSE_Enable();

   /* Wait till HSE is ready */
  while(LL_RCC_HSE_IsReady() != 1)
  {

  }
  LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, LL_RCC_PLLM_DIV_4, 168, LL_RCC_PLLP_DIV_2);
  LL_RCC_PLL_Enable();

   /* Wait till PLL is ready */
  while(LL_RCC_PLL_IsReady() != 1)
  {

  }
  while (LL_PWR_IsActiveFlag_VOS() == 0)
  {
  }
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_4);
  LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_2);
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);

   /* Wait till System clock is ready */
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
  {

  }
  LL_SetSystemCoreClock(168000000);

   /* Update the time base */
  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */



//u8g2_logo_128x64_width 128
//u8g2_logo_128x64_height 64

static const unsigned char u8g2_logo_128x64_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xcf, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x80, 0x83, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xf8,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x07, 0xfc, 0x03, 0x1c, 0x00, 0x3e, 0x1c, 0xc0, 0x03, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xff, 0x07, 0x7f, 0x80, 0xff,
   0x3f, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x07, 0xff,
   0x8f, 0xff, 0xc1, 0xff, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0x87, 0xff, 0xdf, 0xff, 0xc1, 0xc3, 0x07, 0x7c, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0x87, 0x0f, 0xfe, 0xff, 0xe3, 0x81,
   0x03, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x07,
   0xfc, 0xe3, 0xe3, 0x81, 0x07, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0xc7, 0x07, 0xf8, 0xc1, 0xe7, 0x81, 0x87, 0xff, 0x07, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03, 0xf0, 0x80, 0xe7, 0xc3,
   0x87, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03,
   0x70, 0x80, 0xc7, 0xe7, 0x83, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0x80, 0xc7, 0x03, 0x78, 0x80, 0xc7, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x03, 0xf8, 0xc0, 0x87, 0xff,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x80, 0xc7, 0x07,
   0xfc, 0xc1, 0xc7, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x3c, 0xc0, 0x87, 0x0f, 0xfe, 0xff, 0xe3, 0x01, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x78, 0xc0, 0x83, 0xff, 0xdf, 0xff, 0xe3, 0x03,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xf1, 0x03, 0xff,
   0x8f, 0xff, 0xe1, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0x01, 0xfe, 0x0f, 0xff, 0xc0, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x00, 0xfc, 0x03, 0x7c, 0xc0, 0xff,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0xf8,
   0x01, 0x00, 0xe0, 0x01, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x1e, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00,
   0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x20, 0xf0, 0xc7, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xc0, 0xff,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x40, 0x24, 0x20, 0x00, 0x00, 0x08, 0x46, 0x02,
   0x00, 0x80, 0xc0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x6e, 0x6a, 0xc0,
   0xa4, 0x48, 0x04, 0xaa, 0xac, 0x8c, 0xaa, 0xac, 0x00, 0x00, 0x00, 0x00,
   0x6a, 0xa4, 0xaa, 0x20, 0xea, 0xa4, 0x64, 0x66, 0xaa, 0x46, 0x4a, 0x8a,
   0x00, 0x00, 0x00, 0x00, 0x4c, 0xa4, 0xaa, 0x20, 0xaa, 0xa2, 0x44, 0x2a,
   0xaa, 0x28, 0xaa, 0x4c, 0x00, 0x00, 0x00, 0x00, 0xe8, 0xa8, 0x6c, 0xc4,
   0xa4, 0x42, 0xee, 0x2a, 0xcc, 0x26, 0x6c, 0xe8, 0x00, 0x00, 0x00, 0x00,
   0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00 };








/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
