#!/usr/bin/env python3
"""
convert_to_c_array_any_size.py

Usage:
  python convert_to_c_array_any_size.py input.jpg output.h array_name [--width W] [--height H] [--no-resize]

If --width and --height provided, image will be resized to that size (unless --no-resize).
If not provided, original image size is used.

Packs 3 pixels -> 2 bytes:
 byte0 = R4 R3 R2 R1 R0 G5 G4 G3
 byte1 = G2 G1 G0 B4 B3 B2 B1 B0

Writes C header with:
 - const uint8_t array_name[] = { ... };
 - const unsigned array_name_width, array_name_height;
 - const unsigned array_name_bytes_per_row;
 - const unsigned array_name_size; // total bytes
"""
from PIL import Image
import numpy as np
import sys
import os
import argparse
import textwrap

def parse_args():
    p = argparse.ArgumentParser(description="Convert image to packed 5-bit grayscale C array")
    p.add_argument("input", help="Input image (JPEG/PNG...)")
    p.add_argument("output", help="Output .h file")
    p.add_argument("array_name", help="Name of C array (e.g., image_data)")
    p.add_argument("--width", type=int, help="Target width (pixels). If omitted, use image width.")
    p.add_argument("--height", type=int, help="Target height (pixels). If omitted, use image height.")
    p.add_argument("--no-resize", action="store_true", help="Do not resize the image; use its original size")
    p.add_argument("--bytes-per-line", type=int, default=12, help="Hex items per line in generated .h (readability)")
    return p.parse_args()

def load_image(path):
    img = Image.open(path).convert('RGB')
    return img

def resize_or_pad(img, target_w, target_h, no_resize=False):
    if no_resize:
        return img
    # Resize preserving aspect ratio then center-pad if needed
    img_thumb = img.copy()
    img_thumb.thumbnail((target_w, target_h), Image.LANCZOS)
    if img_thumb.size == (target_w, target_h):
        return img_thumb
    out = Image.new('RGB', (target_w, target_h), (0,0,0))
    x = (target_w - img_thumb.width) // 2
    y = (target_h - img_thumb.height) // 2
    out.paste(img_thumb, (x,y))
    return out

def rgb_to_luma_8bit(rgb_arr):
    r = rgb_arr[...,0].astype(np.float32)
    g = rgb_arr[...,1].astype(np.float32)
    b = rgb_arr[...,2].astype(np.float32)
    y = 0.299*r + 0.587*g + 0.114*b
    return np.clip(y,0,255).astype(np.uint8)

def quantize5(y8):
    return ((y8.astype(np.uint16) * 31 + 127) // 255).astype(np.uint8)

def pack_triplet(r5, g5, b5):
    r = int(r5) & 0x1F
    g = int(g5) & 0x1F
    b = int(b5) & 0x1F
    byte0 = ((r & 0x1F) << 3) | ((g >> 2) & 0x07)
    byte1 = (((g & 0x07) << 5) | (b & 0x1F)) & 0xFF
    return byte0 & 0xFF, byte1

def convert_image_to_bytes(img):
    arr = np.array(img)  # H,W,3
    luma = rgb_to_luma_8bit(arr)
    q5 = quantize5(luma)
    H,W = q5.shape
    pad = (3 - (W % 3)) % 3
    if pad:
        q5 = np.pad(q5, ((0,0),(0,pad)), constant_values=0)
        W = q5.shape[1]
    out = bytearray()
    for y in range(H):
        x = 0
        while x < W:
            r5 = int(q5[y, x + 0])
            g5 = int(q5[y, x + 1])
            b5 = int(q5[y, x + 2])
            b0, b1 = pack_triplet(r5, g5, b5)
            out.append(b0)
            out.append(b1)
            x += 3
    return out, q5.shape[1]  # return padded width too

def write_c_header(path_out, array_name, data_bytes, width, height, padded_width, bytes_per_line=12):
    total = len(data_bytes)
    bytes_per_row = ((width + 2) // 3) * 2
    hex_items = [f"0x{b:02X}" for b in data_bytes]
    lines = []
    for i in range(0, len(hex_items), bytes_per_line):
        chunk = ", ".join(hex_items[i:i+bytes_per_line])
        if i + bytes_per_line < len(hex_items):
            chunk += ","
        lines.append("  " + chunk)
    header = []
    header.append("// Generated by convert_to_c_array_any_size.py")
    header.append(f"// Image size: {width} x {height} (padded width for packing: {padded_width})")
    header.append(f"// bytes_per_row = {bytes_per_row}, total bytes = {total}")
    header.append("")
    header.append("#include <stdint.h>")
    header.append("")
    header.append(f"const uint8_t {array_name}[] = {{")
    header.extend(lines)
    header.append("};")
    header.append("")
    header.append(f"const unsigned {array_name}_width = {width};")
    header.append(f"const unsigned {array_name}_height = {height};")
    header.append(f"const unsigned {array_name}_bytes_per_row = {bytes_per_row};")
    header.append(f"const unsigned {array_name}_size = {total};")
    with open(path_out, "w", newline="\n") as f:
        f.write("\n".join(header))
    print(f"Wrote {total} bytes -> {path_out}")

def main():
    args = parse_args()
    if not os.path.isfile(args.input):
        print("Input not found:", args.input); sys.exit(1)
    img = load_image(args.input)
    # Determine target size
    if args.width and args.height:
        target_w = args.width
        target_h = args.height
    elif args.width and not args.height:
        target_w = args.width
        target_h = img.height * args.width // img.width
    elif args.height and not args.width:
        target_h = args.height
        target_w = img.width * args.height // img.height
    else:
        target_w = img.width
        target_h = img.height

    if not args.no_resize:
        img_prepared = resize_or_pad(img, target_w, target_h, no_resize=False)
    else:
        # If no resize but target differs, we use original image size
        img_prepared = img
        target_w = img_prepared.width
        target_h = img_prepared.height

    data_bytes, padded_width = convert_image_to_bytes(img_prepared)
    write_c_header(args.output, args.array_name, data_bytes, target_w, target_h, padded_width, args.bytes_per_line)

if __name__ == "__main__":
    main()